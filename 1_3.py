'''
Функции и стек вызовов
Определение функции выполняется целиком 
После того как интерпретатор прочитал все тело функции, он создает объект в оперативн. пам. с этой функцией

'''
#Например:
def function_name (argument1, argument2):
    return argument1 + argument2

x = function_name(2, 8)
y = function_name(x, 21)
#print(y)
#print(type(function_name))
# print(id(function_name))
'''
Объект функции хранит в себе очень много, и имя, и аргументы
До исполнения тела происходит инициализация аргументов
(аргумент1 и аргумент2 сошлются на объекты переданные при вызове функции)
Далее будет выполняться код в теле построчно
Тогда результатом будет ссылка на возвращенный объект
'''
def list_sum(lst):
    result = 0
    for element in lst:
        result += element
    return result

def sum (a, b):
    return a + b

y = sum(14, 29)
z = list_sum([1, 2, 3])
#print(y)
#print(z)

'''
Каждая функция лежащая в стеке и имеющая выше вызванную функцию
не будет выполнена пока не закончится выполнение выше лежащей ф-ции
'''
# Реализация стека с помощью списка
x = [1, 2, 3]

x.append(4)
x.append(5)
print(x)
top = x.pop()
print(top)
top = x.pop()
print(top)
print(x)

'''
Если ф-ция ничего не возвращает, или содержит пустой return, тогда
будет возвращен объект "none"
Проверить ссылается ли объект на none можно через
x is none
'''
#1

def closest_mod_5(x):
    return x if x % 5 == 0 else closest_mod_5(x + 1)

#print(closest_mod_5(6))

'''
Если функция ожидает ограниченное количество агрументов и ни обязательные,
то функуия не может быть выполнена пока не будут инициализированы все эти 
аргументы

Если функция принимает несколько значений, а у нас есть массив этих значений
тогда их можно передать следующим образом

def fun_1 (a, b, c)
    return a + b + c

list = [1, 2, 3]
fun_1(*list)
или если нужно передать словарем
fun_2(**dict)  # здесь будут переданы ключ-значение, что в конечном счете
               # значит просто переданное значение без ключа
'''
'''
Синтаксис для приема аргументов:
Если аргументы должны быть строго переданы
def fun(a, b)
    print(a)
    print(b)
Так же можно задать значение одного или дву аргументов по умолчанию
тогда в случае, если мы ничего не передадим, функция все равно исполнится
используя аргументы поуполчанию
def fun(a, b=1)
    print(a)
    print(b)
или
def fun(a=10, b=1)
    print(a)
    print(b)
Однако нельзя создавать функицю с первым аргументом по уполчанию,
а вторым обязательным
def fun(a=10, b)  # Нельзя!
    print(a)
    print(b)
Если необходимо принять неограниченное (неопределенное) количество
аргументов можно использовать список или словарь(если нужны
именованные аргументы)
def fun(a, b, *arg): # для словаря две звездочки
    print(a)
    print(b)
    for i in arg:
        print(i)

'''
def s(a, *vs, b=10):
   res = a + b
   for v in vs:
       res += v
   return res

#print(s(0, 0, 31))
#print(s(11, b=20)) 
#print(s(21))
#print(s(11, 10, 10))
#print(s(11, 10, b=10))
#print(s(5, 5, 5, 5, 1))
#print(s(11, 10))

#1

n, k = map(int, input().split())

def factorial(f):
    if f == 1:
        return f
    else:
        return f * factorial(f-1)


def сombination(n, k):
    if k > n:
        return 0
    elif k == 0:
        return 1
    elif n == k:
        return 1
    else:
        return int(factorial(n) / factorial(n-k) / factorial(k)) 

print(сombination(n, k))











